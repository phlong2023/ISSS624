{
  "hash": "caec5d3f6e7784dc805507b1b067165d",
  "result": {
    "markdown": "---\ntitle: \"Hands-on_Ex2_Global_Measures\"\ndate: '22 November 2023'\ndate-modified: 'last-modified'\nformat: html\nexecute: \n  eval: true # run the code live\n  echo: true # all code will appear\n  warning: false # hide all warnings\neditor: visual\n---\n\n\n## Overview\n\nThe goal of this hands-on exercise is to compute Global and Local Measures of Spatial Autocorrelation (GLSA).\n\n## Getting Started\n\n### The Analytical Question\n\nIn spatial policy, one of the main development objectives of the local government and planners is to ensure equal distribution of development in the province.\n\nOur task is to apply appropriate spatial statistical methods to discover if development are evenly distributed geographically.\n\n-   If the answer is **No,** then our next question will be \"is there a sign of spatial clustering?\".\n\n    -   If the answer is **Yes,** then our next question will be \"Where are the clusters?\".\n\nIn this case study, we are interested to examine the spatial pattern of a selected development indicator (i.e. GDP per capita) of [Hunan Province, People's Republic of China (PRC)](https://en.wikipedia.org/wiki/Hunan).\n\n### The Study Area and Data\n\nTwo data sets will be used:\n\n1.  Hunan Province administrative boundary layer at county level. This is a geospatial dataset in ESRI shapefile format\n2.  Hunan_2012.csv: This csv file contains selected Hunan's local development indicators in 2012\n\n### Loading the Required Packages\n\nWe can use *p_load()* in the pacman package to load the required packages for data analysis: [spdep](https://r-spatial.github.io/spdep/) (for spatial weights), [sf](https://r-spatial.github.io/sf/), [tmap](https://r-tmap.github.io/tmap/), and [tidyverse](https://www.tidyverse.org/).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(spdep, sf, tmap, tidyverse)\n```\n:::\n\n\n## Getting the Data into R Environment\n\n### Import shapefile into R\n\n*st_read()* can be used to import the Hunan shapefile into R as a simple features object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- st_read(dsn = 'data/geospatial',\n                 layer = 'Hunan')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `D:\\phlong2023\\ISSS624\\Hands-on_Ex\\Hands-on_Ex2\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\n### Import csv file into R\n\n*read_csv()* can be used to import the Hunan_2012.csv into R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan2012 <- read_csv('data/aspatial/Hunan_2012.csv')\n```\n:::\n\n\n### Performing Relational Join\n\n*left_join()* can be used to join the attribute fields in hunan2012 with the hunan simple feature object.\n\n::: callout-note\nNote that *left_join()* automatically seeks out the shared column to join the data frames. However it can also by specified with the syntax: by = join_by(County)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhunan <- left_join(hunan, hunan2012) %>%\n  select(1:4, 7, 15)\n```\n:::\n\n\n### Visualizing Regional Development Indicator\n\nThe tmap package can be used to prepare choropleth maps to show the distribution of GDP per capita (GDPPC) according to different breaks style ('equal', 'quantile').\n\n\n::: {.cell}\n\n```{.r .cell-code}\nequal <- tm_shape(hunan)+\n  tm_fill('GDPPC',\n          n = 5,\n          style = 'equal')+\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = 'Equal Interval Classification')\n\nquantile <- tm_shape(hunan)+\n  tm_fill('GDPPC',\n          n = 5,\n          style = 'quantile')+\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = 'Equal Quantile Classification')\n\ntmap_arrange(equal, quantile, asp = 1, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_Global_Measures_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Global Spatial Autocorrelation\n\n### Computing Contiguity Spatial Weights\n\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. **The spatial weights is used to define the neighbourhood relationships between the geographical units in the study area**.\n\n*poly2nb()* is used to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries. For this case study, we will use a Queen contiguity criteria, which look like below.\n\n![](images/Queen_Contiguity.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(hunan, queen = TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n```\n:::\n:::\n\n\nThe summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours (area 85). There are two area units with only 1 neighbour (30 and 65).\n\n### Row-standardized Weights Matrix\n\nNext, we need to assign weights to each neighboring polygon.\n\nIn our case, each neighboring polygon will be assigned equal weight (style = 'W'). This is accomplished by assigning 1/(#ofneighbors) to each neighboring county then summing the weighted income values.\n\nWhile this is the most intuitive way to summarize the neighbors' values, it has one drawback in that polygons along the edges of the study area will base their lagged values on fewer polygons, thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_q <- nb2listw(wm_q,\n                   style = 'W',\n                   zero.policy = TRUE)\nrswm_q\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n```\n:::\n:::\n\n\nThe input of *nb2listw()* must be an object of class **nb.** The syntax of the function has two major arguments:\n\n1.  *style:* can take values 'W', 'B', 'C', 'U', 'minmax' and 'S'. B is the classic binary coding, W is row standardized (sums over all links to n), C is globally standardized (sums over all links to n), U is equal to C divided by the number of neighbours (sums over all links to unity), while S is the variance-stabilizing coding scheme proposed by Tiefelsdorf et al. 1999, p. 167-168 (sums over all links to n).\n2.  *zero policy:* if set to TRUE, weights vectors of zero length are inserted for regions without neighbour in the neighbours list. These will in turn generate lag values of zero, equivalent to the sum of products of the zero row t(rep(0, length=length(neighbours))) %\\*% x, for arbitrary numerical vector x of length length(neighbours). The spatially lagged value of x for the zero-neighbour region will then be zero, which may (or may not) be a sensible choice.\n\n### Global Spatial Autocorrelation: Moran's I\n\n#### Moran's I test\n\n*moran.test()* in **spdep** can be used to perform Moran's I statistical test\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoran.test(hunan$GDPPC,\n           listw = rswm_q,\n           zero.policy = TRUE,\n           na.action = na.omit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n:::\n:::\n\n\n**Question:** What statistical conclusion can you draw from the output above?\n\n**Answer:** As the p-value is below the alpha level of 5%, the result of the Moran's I test is statistically significant and since the Moran I statistics is positive, we can conclude that there is positive spatial autocorrelation, or that similar values are spatially clustered.\n\n#### Monte Carlo Moran's I\n\n*moran.mc()* can be used to performs permutation test for Moran's I statistic. A total of 1000 simulation will be performed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm <- moran.mc(hunan$GDPPC,\n                 listw = rswm_q,\n                 nsim = 999,\n                 zero.policy = TRUE,\n                 na.action = na.omit)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n:::\n\n\n**Question:** What statistical conclusion can you draw from the output above?\n\n**Answer:** The permutation test supports the result of the Moran's I. As the p-value is 0.001, only 0.1% of the values equal or exceed it, the result of the Moran's I test is statistically significant and since the Moran I statistics is positive, we can conclude that there is positive spatial autocorrelation, or that similar values are spatially clustered.\n\n#### Visualizing Monte Carlo Moran's I\n\nIt is good practice to examine the simulated Moran's I test statistics in greater detail. This can be achieved by plotting the distribution of the statistical values as a histogram.\n\n*mean()* can be used to get the mean of the simulated values of statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.01504572\n```\n:::\n:::\n\n\n*var()* can be used to get the variance of the simulated values of statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.004371574\n```\n:::\n:::\n\n\n*summary()* can be used to get the summary statistics of the simulated values of statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n```\n:::\n:::\n\n\n*hist()* and *abline()* can be used to create a histogram of the simulated values of statistic of the Monte Carlo Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res,\n     freq = TRUE,\n     breaks = 20,\n     xlab = \"Simulated Moran's I\")\nabline(v=0,\n       col='red')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_Global_Measures_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n**Question:** What statistical observation can you draw from the output above?\n\n**Answer:** It can be seen that that a very small number of values exceed or equal the value of I at 0.3, meaning that the autocorrelation is statistically significant. Additionally, since the simulated values of statistic is not normally distributed, it demonstrates the reliability of the permutation test to identify statistically significant autocorrelation.\n\n### Global Spatial Autocorrelation: Geary's\n\n#### Geary's C test\n\n*geary.test()* can be used to perform Geary's C test for spatial autocorrelation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeary.test(hunan$GDPPC, listw = rswm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tGeary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n```\n:::\n:::\n\n\n**Question:** What statistical conclusion can you draw from the output above?\n\n**Answer:** Geary's C value ranges from 0 to 2 where 1 is no spatial autocorrelation. Since the statistic is 0.69, it suggests that there is slight positive spatial correlation. Additionally since the p-value is very small, the result is statistically significant.\n\n#### Computing Monte Carlo Geary's C\n\nA permutation test (Monte Carlo Geary's C) can be performed using *geary.mc()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nbperm <- geary.mc(hunan$GDPPC,\n                  listw = rswm_q,\n                  nsim = 999)\nbperm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n:::\n\n\n**Question:** What statistical conclusion can you draw from the output above?\n\n**Answer:** The permutation test supports the result of the Geary's C test. Since p-value is 0.001, the result is statistically significant. Furthermore, as the test statistic is 0.69, it can be concluded that there is positive spatial autocorrelation.\n\n#### Visualizing the Monte Carlo Geary's C\n\n*mean()* can be used to get the mean of the simulated values of statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.004402\n```\n:::\n:::\n\n\n*var()* can be used to get the variance of the simulated values of statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.007436493\n```\n:::\n:::\n\n\n*summary()* can be used to get the summary statistic of the simulated values of statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bperm$res[1:999])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.7142  0.9502  1.0052  1.0044  1.0595  1.2722 \n```\n:::\n:::\n\n\n*hist()* and *abline()* can be used to create a histogram of the simulated values of statistic of the Geary's C.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(bperm$res,\n     freq = TRUE,\n     breaks = 20,\n     xlab = 'Simulated Geary C')\nabline(v=1, col='red')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_Global_Measures_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n**Question:** What statistical observation can you draw from the output?\n\n**Answer:** The simulated values is normally distributed around 1, which is one of the implicit assumption of the Geary's C test.\n\n## Spatial Correlogram\n\nSpatial correlograms are great to examine patterns of spatial autocorrelation in the data or model residuals.\n\nThey show how correlated are pairs of spatial observations when you increase the distance (lag) between them. They are plots of some index of autocorrelation (Moran's I or Geary's C) against distance.\n\nAlthough correlograms are not as fundamental as variograms (a keystone concept of geostatistic), they are very useful as an exploratory and descriptive tool. For this purpose, they actually provide richer information than variograms.\n\n### Compute Moran's I Correlogram\n\n*sp.correlogram()* can be used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used is Moran's I. *plot()* is then used to plot the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_corr <- sp.correlogram(wm_q,\n                          hunan$GDPPC,\n                          order = 6,\n                          method = 'I', style = 'W')\n\nplot(MI_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_Global_Measures_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nPlotting the output might not allow us to provide complete interpretation. This is because not all autocorrelation values are statistically significant. Hence, it is important for us to examine the full analysis report by printing out the analysis results as in the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(MI_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\n**Question:** What statistical observation can you draw from the plot above?\n\n**Answer:** All pairs of results are statistically significant, except for number 4 with a p-value larger than 0.05. This shows that the list of IDs in number 4 do not exhibit spatial autocorrelation with their neighbors.\n\n### Compute Geary's C correlogram and plot\n\n*sp.correlogram()* can be used to compute a 6-lag spatial correlogram of GDPPC. The global spatial autocorrelation used is Geary's C. *plot()* is then used to plot the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGC_corr <- sp.correlogram(wm_q,\n                          hunan$GDPPC,\n                          order = 6,\n                          method = 'C', style = 'W')\nplot(GC_corr)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex2_Global_Measures_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nWe will print out the analysis report using *print().*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(GC_corr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex2_Global_Measures_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}