{
  "hash": "2763160700d5e8db966cf95932ecea75",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 1: Choropleth Mapping with R\"\ndate: '16 November 2023'\ndate-modified: 'last-modified'\nformat: html\nexecute: \n  eval: true # run the code live\n  echo: true # all code will appear\n  warning: false # hide all warnings\neditor: visual\n---\n\n\n## Overview\n\nChoropleth mapping involves the symbolisation of enumeration units, such as countries, provinces, states, counties or census units, using area patterns or graduated colors. For example, a social scientist may need to use a choropleth map to portray the spatial distribution of aged population of Singapore by Master Plan 2014 Subzone Boundary.\n\nThis can be done using the [tmap](https://r-tmap.github.io/tmap/) package. We can load this and other required packages (sf, tidyverse) using the code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse, tmap)\n```\n:::\n\n\n## Importing Data into R\n\n### The Data\n\nTwo datasets will be used:\n\n1.  Master Plan 2014 Subzone Boundary (Web) in ESRI shapefile format. It consists of geographical boundary of Singapore at the planning subzone level and is babsed on the URA Master Plan 2014.\n2.  Singapore Residents by Planning Area/Subzone, Age Grouu, Sex, and Type of Dwelling, June 2011-2020 csv format. This is aspatial data. Its PA and SZ fields can be used to geocode to the Master Plan 2014 Subzone Boundary (Web) shapefile.\n\n### Importing Geospatial Data into R\n\nst_read() can be used to read the Master Plan 2014 shapefile into an R dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = 'data/geospatial',\n                layer = 'MP14_SUBZONE_WEB_PL')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `D:\\phlong2023\\ISSS624\\Hands-on_Ex\\Hands-on_Ex1\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n:::\n:::\n\n\nglimpse() and head() can be used to look at the data types and first few rows of data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mpsz)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(mpsz, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n```\n:::\n:::\n\n\n### Importing Attribute Data into R\n\nFor the resident population data, read_csv() will be used as it is stored as a csv\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata <- read_csv('data/aspatial/respopagesexfa2011to2020.csv')\n```\n:::\n\n\n## Data Preparation\n\nBefore a thematic map can be prepared, you are required to prepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.\n\nThis table would have the rows be each unique PA and SZ and with the following new columns:\n\n1.  YOUNG: number of people from age group 0-4 to age group 20-24\n2.  ECONOMY ACTIVE: number of people from age group 25-29 to age group 60-64\n3.  AGED: number of people age group 65 +\n4.  TOTAL: number of people in all age groups\n5.  DEPENDENCY: the ratio between YOUNG + AGED against ECONOMY ACTIVE\n\n### Data Wrangling\n\nThe following data wrangling and transformation functions will be used:\n\n1.  pivot_wider(): To pivot the dataframe from long to wide format with rows becoming new columns\n2.  mutate(), filter(), and group_by(): Creating new columns, filtering, and group columns based on value of some columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>% #Getting only 2020 data\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>% #Summarizing by population based on the group_by\n  ungroup() %>%\n  pivot_wider(names_from = AG,\n              values_from = POP)%>% #pivot wider based on names in AG and values from POP\n  mutate(YOUNG = rowSums(.[3:6])+rowSums(.[14])) %>%\n  mutate(`ECONOMY ACTIVE` = rowSums(.[7:13])+rowSums(.[15]))%>%\n  mutate(`AGED` = rowSums(.[16:21])) %>%\n  mutate(`TOTAL` = rowSums(.[3:21])) %>%\n  mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, `ECONOMY ACTIVE`, `AGED`, `TOTAL`, `DEPENDENCY`)\n```\n:::\n\n\n### Joining the attribute data and geospatial data\n\nCurrently, the values of the PA and SZ fields are a mix of lower and uppercase characters while the values in SUBZONE_N and PLN_AREA_N are all uppercase.\n\nWe need to convert the values in PA and SZ fields to uppercase.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata2020 %>%\n  mutate_at(.vars = vars(PA, SZ), #Apply the toupper function to multiple columns\n            .funs = list(toupper)) %>% \n  filter(`ECONOMY ACTIVE` > 0)\n```\n:::\n\n\nleft_join() can then be used to join the geographical data and attribute table based on SZ being the same as SUBZONE_N. left_join() is used with the simple feature dataframe (mpsz) as the left data table to ensure the output will be a simple features dataframe; it will also keep all observations in mpsz.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c('SUBZONE_N' = 'SZ'))\n```\n:::\n\n\nNow, we can use write_rds to create a new rds (R Data Serialization) file with the new dataframe\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(mpsz_pop2020, 'data/rds/mpszpop2020.rds')\n```\n:::\n\n\n## Choropleth Mapping Geospatial Data using *tmap*\n\n### Plotting a choropleth map quickly by using *qtm()*\n\nDefault visualization using qtm(). Note that tmap_mode() with \"plot\" is used to produce a static map. For interactive mode, \"view\" should be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\nqtm(mpsz_pop2020,\n    fill = 'DEPENDENCY') #the DEPENDENCY column will be used for the color variation\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n### Creating a choropleth map by using tmap's elements\n\nDespite its usefulness of drawing a choropleth map quickly and easily, the disadvantge of *qtm()* is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, **tmap**'s drawing elements should be used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          style='quantile',\n          palette = 'Blues',\n          title = 'Dependency ration')+\n  tm_layout(main.title = 'Distribution of Dependency Ratio by planning subzone',\n            main.title.position = 'center',\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)+\n  tm_borders(alpha = 0.5)+\n  tm_compass(type='8star',size=2)+\n  tm_scale_bar()+\n  tm_grid(alpha = 0.2)+\n  tm_credits('Sourrce: Planning Sub-zone boundary from Urban Redevelopment Authority \\n and Population data from Department of Statistics (DOS)',\n             position = c('left','bottom'))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nThe following sections will explain each step of the process executed in the code chunk above\n\n### Drawing a base map\n\nThe basic building block of tmap is *tm_shape()* which is used to define the input data and *tm_polygons()* which is used to draw the planning subzone polygons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n### Drawing a choropleth map using *tm_polygons()*\n\ntm_polygons() can be modified with the target variable in order to draw the choropleth map showing the geographical distribution of the selected variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons('DEPENDENCY')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nThings to learn from *tm_polygons()*:\n\n-   The default interval binning used to draw the choropleth map is called \"pretty\".\n\n-   The default colour scheme used is `YlOrRd` of ColorBrewer.\n\n-   By default, Missing value will be shaded in grey.\n\n### Drawing a choropleth map using *tm_fill()* and *tm_border()*\n\ntm_polygons() is a wrapper of tm_fill() and tm_border():\n\n1.  tm_fill() shades the polygons by using the default colour scheme\n2.  tm_borders() adds the borders of the shapefile onto the choropleth map\n\nIf you use tm_fill() alone, there will be no border between the subzones. The planning subzones are shared according to the respective dependency values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\ntm_borders() can be used to add the boundary of the planning subzones. tm_borders() has three arguments:\n\n-   alpha: transparency of the line\n\n-   col: border colour\n\n-   lwd: line width\n\n-   lty: line type\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY')+\n  tm_borders(lwd = 0.1, alpha = 1)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n### Data classification methods of tmap\n\nMost choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.\n\n**tmap** provides a total ten data classification methods, namely: *fixed*, *sd*, *equal*, *pretty* (default), *quantile*, *kmeans*, *hclust*, *bclust*, *fisher*, and *jenks*.\n\nTo define a data classification method, the *style* argument of *tm_fill()* or *tm_polygons()* will be used.\n\n#### Plotting choropleth maps with built-in classification methods\n\n**jenks** data classification method\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          n = 5, #number of classes\n          style = 'jenks')+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n**equal** data classification method\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          n = 5,\n          style = 'equal')+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n**quantile** data classification method\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          n = 5,\n          style = 'quantile')+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nThe distribution of quantile data classification method are more evenly distributed then equal data classification method.\n\nUsing the quantile style with different numbers of classes\n\n2 classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          n = 2,\n          style = 'quantile')+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n6 classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          n = 6,\n          style = 'quantile')+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n10 classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          n = 10,\n          style = 'quantile')+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n#### Plotting choropleth map with custom break\n\nFor all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the *breaks* argument to the *tm_fill()*. It is important to note that, in **tmap** the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the ***breaks*** option (the values must be in increasing order).\n\nsummary() can be used to get some descriptive statistics on the variable 'DEPENDENCY' before setting break points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mpsz_pop2020$DEPENDENCY)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6540  0.7063  0.7712  0.7657 19.0000      92 \n```\n:::\n:::\n\n\nWith reference to the results above and the need to include a minimum and maximum (0 and 100), we can set our breaks with the vector c(0, 0.5, 0.6, 0.7, 0.8, 1.00)\n\nNow we can plot the choropleth map with custom breaks\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          breaks = c(0, 0.5, 0.6, 0.7, 0.8, 1.00))+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n### Colour Scheme\n\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package\n\n#### Using ColourBrewer palette\n\nTo change the colour, we assigned the preferred colour to the *palette* argument of *tm_fill()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          n = 6,\n          style = 'quantile',\n          palette = 'Blues')+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nWe can also reverse the color scheme (darker for lower values) by adding a '-' prefix to the palette argument\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          n = 6,\n          style = 'quantile',\n          palette = '-Blues')+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n## Map Layouts\n\nMap layout refers to the combination of all map elements into a cohensive map. Map elements include among others the objects to be mapped, the title, the scale bar, the compass, margins and aspects ratios. Colour settings and data classification methods covered in the previous section relate to the palette and break-points are used to affect how the map looks.\n\n### Map Legend\n\nIn **tmap**, several *legend* options are provided to change the placement, format and appearance of the legend.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          style = 'jenks',\n          palette = 'Blues',\n          legend.hist = TRUE,\n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1)+\n  tm_layout(main.title = 'Distribution of Dependency Ratio by planning subzone \\n (Jenks Classification)',\n            main.title.position = 'center',\n            main.title.size = 1,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c('right','bottom'),\n            frame = FALSE)+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n### Map Style\n\n**tmap** allows a wide variety of layout settings to be changes. They can be called by using *tmap_style()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = '-Greens')+\n  tm_borders(alpha = 0.5)+\n  tmap_style('classic')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n### Cartographic Furniture\n\nBeside map style, **tmap** also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.\n\n*tm_compass()* can be used to add a compass.\n\n*tm_scale_bar()* can be used to add a scale bar.\n\n*tm_grid()* can be used to add grid lines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Blues',\n          title = 'No. of persons')+\n  tm_layout(main.title = 'Distribution of Dependency Ratio by planning subzone \\n (Jenks Classification)',\n            main.title.position = 'center',\n            main.title.size = 1.2,\n            legend.height = 0.45,\n            legend.width = 0.35,\n            frame = TRUE)+\n  tm_borders(alpha = 0.5)+\n  tm_compass(type = '8star', size = 2)+\n  tm_scale_bar(width = 0.15)+\n  tm_grid(lwd = 0.1, alpha = 0.2)+\n  tm_credits('Source: Planning Sub-zone boundary from Urban Redevelopment Authority (URA) \\n and Population data from Department of Statistic (DOS)',\n             position = c('left','bottom'))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nTo reset to the default style, use tmap_style('white')\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_style('white')\n```\n:::\n\n\n## Drawing Small Multiple Choropleth Maps\n\n**Small multiple maps**, also referred to as **facet maps**, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.\n\nIn **tmap,** small multiple maps can be plotted in three ways:\n\n1.  by assigning multiple values to at least one of the aesthetic arguments\n2.  by defining a group-by variable in *tm_facets()*\n3.  by creating multiple standalone maps with *tmap_arrange()*\n\n### By assigning multiple values to at least one of the aesthetic arguments\n\nThe **ncols** argument in *tm_fill()* can be used to make multiple choropleth maps\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(c('YOUNG','AGED'),\n          style = 'equal',\n          palette = 'Blues')+\n  tm_layout(legend.position = c('right','bottom'))+\n  tm_borders(alpha = 0.5)+\n  tmap_style('white')\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(c('DEPENDENCY','AGED'),\n              style = c('equal','quantile'),\n              palette = list('Blues','Greens'))+\n  tm_layout(legend.position = c('right','bottom'))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n### By defining a group-by variable in *tm_facets()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Blues',\n          thres.poly = 0)+\n  tm_facets(by = 'REGION_N',\n            free.coords = TRUE,\n            drop.shapes = TRUE)+\n  tm_layout(legend.show = FALSE,\n            title.position = c('center','center'),\n            title.size = 20)+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n### By creating multiple stand-alone maps with *tmap_arrange()*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyoungmap <- tm_shape(mpsz_pop2020)+\n  tm_polygons('YOUNG',\n              style = 'quantile',\n              palette = 'Blues')\n\nagedmap <- tm_shape(mpsz_pop2020)+\n  tm_polygons('AGED',\n              style = 'quantile',\n              palette = 'Blues')\n\ntmap_arrange(youngmap, agedmap, asp = 1, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n## Mapping Spatial Object Meeting a Selection Criterion\n\nSelection function can be used to map spatial objects meeting the selection criterion\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N=='CENTRAL REGION',])+\n  tm_fill('DEPENDENCY',\n          style = 'quantile',\n          palette = 'Blues',\n          legend.hist = TRUE,\n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1)+\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45,\n            legend.width = 5.0,\n            legend.position = c('right','bottom'),\n            frame = FALSE)+\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex1_Choropleth_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex1_Choropleth_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}